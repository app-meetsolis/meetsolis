import { AIService, ServiceStatus, ServiceInfo } from '@meetsolis/shared';
import { BaseService } from '../base-service';

export class MockAIService extends BaseService implements AIService {
  private templateResponses = new Map<string, string[]>();
  private requestCount = 0;

  constructor() {
    super();
    this.enableFallbackMode();
    this.initializeTemplates();
  }

  private initializeTemplates() {
    // Meeting summary templates
    this.templateResponses.set('summary', [
      'Meeting Summary: The team discussed project milestones and deliverables. Key decisions were made regarding timeline and resource allocation.',
      'Meeting Summary: Product roadmap reviewed with stakeholders. Priority features identified for next quarter development cycle.',
      'Meeting Summary: Technical architecture discussion covering scalability requirements and implementation strategies.',
    ]);

    // Text analysis templates
    this.templateResponses.set('analysis', [
      'Analysis: Positive sentiment detected with focus on collaboration and progress.',
      'Analysis: Technical discussion with emphasis on performance and scalability concerns.',
      'Analysis: Strategic planning session with clear action items identified.',
    ]);
  }

  async isAvailable(): Promise<boolean> {
    return true;
  }

  getServiceInfo(): ServiceInfo {
    return {
      name: 'Mock AI Service',
      version: '1.0.0',
      description:
        'Mock AI service providing template-based responses for development and testing',
      dependencies: [],
    };
  }

  protected async performHealthCheck(): Promise<ServiceStatus> {
    await new Promise(resolve => setTimeout(resolve, 100));

    return {
      status: 'healthy',
      responseTime: 100,
      lastCheck: new Date(),
      errorCount: 0,
    };
  }

  async generateSummary(text: string): Promise<string> {
    console.log(
      '[MockAIService] Generating summary for text length:',
      text.length
    );

    this.requestCount++;

    // Simulate AI processing delay
    await new Promise(resolve =>
      setTimeout(resolve, 1000 + Math.random() * 2000)
    );

    const templates = this.templateResponses.get('summary') || [];
    const randomTemplate =
      templates[Math.floor(Math.random() * templates.length)];

    // Add some text analysis
    const wordCount = text.split(/\s+/).length;
    const keywordAnalysis = this.extractKeywords(text);

    return `${randomTemplate}\n\nText Analysis:\n- Word count: ${wordCount}\n- Key topics: ${keywordAnalysis.join(', ')}\n- Generated by: Mock AI Service (Token usage: ${Math.floor(wordCount * 1.2)})`;
  }

  async analyzeText(text: string): Promise<any> {
    console.log(
      '[MockAIService] Analyzing text:',
      text.substring(0, 50) + '...'
    );

    this.requestCount++;

    // Simulate analysis delay
    await new Promise(resolve =>
      setTimeout(resolve, 800 + Math.random() * 1200)
    );

    const wordCount = text.split(/\s+/).length;
    const keywords = this.extractKeywords(text);
    const sentiment = this.analyzeSentiment(text);

    return {
      wordCount,
      characterCount: text.length,
      keywords,
      sentiment,
      language: 'en',
      topics: this.identifyTopics(text),
      confidence: 0.85 + Math.random() * 0.14, // Mock confidence score
      processingTime: Date.now(),
      tokensUsed: Math.floor(wordCount * 1.3),
    };
  }

  private extractKeywords(text: string): string[] {
    // Simple keyword extraction
    const words = text
      .toLowerCase()
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 3);

    // Remove common words
    const stopWords = new Set([
      'that',
      'this',
      'with',
      'from',
      'they',
      'have',
      'been',
      'will',
      'would',
      'could',
      'should',
    ]);
    const filteredWords = words.filter(word => !stopWords.has(word));

    // Return most frequent words
    const wordCount = new Map<string, number>();
    filteredWords.forEach(word => {
      wordCount.set(word, (wordCount.get(word) || 0) + 1);
    });

    return Array.from(wordCount.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }

  private analyzeSentiment(text: string): { score: number; label: string } {
    // Simple sentiment analysis
    const positiveWords = [
      'good',
      'great',
      'excellent',
      'success',
      'achieve',
      'progress',
      'improve',
    ];
    const negativeWords = [
      'bad',
      'poor',
      'fail',
      'problem',
      'issue',
      'concern',
      'delay',
    ];

    const words = text.toLowerCase().split(/\s+/);
    let score = 0;

    words.forEach(word => {
      if (positiveWords.some(pos => word.includes(pos))) score += 1;
      if (negativeWords.some(neg => word.includes(neg))) score -= 1;
    });

    const normalizedScore = Math.max(
      -1,
      Math.min(1, (score / words.length) * 10)
    );

    let label = 'neutral';
    if (normalizedScore > 0.3) label = 'positive';
    else if (normalizedScore < -0.3) label = 'negative';

    return { score: normalizedScore, label };
  }

  private identifyTopics(text: string): string[] {
    const topicKeywords = {
      technology: [
        'system',
        'software',
        'development',
        'code',
        'api',
        'database',
      ],
      business: [
        'market',
        'customer',
        'revenue',
        'strategy',
        'growth',
        'sales',
      ],
      project: [
        'deadline',
        'milestone',
        'deliverable',
        'timeline',
        'task',
        'scope',
      ],
      team: [
        'collaboration',
        'communication',
        'meeting',
        'discussion',
        'team',
        'member',
      ],
    };

    const lowerText = text.toLowerCase();
    const identifiedTopics: string[] = [];

    Object.entries(topicKeywords).forEach(([topic, keywords]) => {
      const matches = keywords.filter(keyword => lowerText.includes(keyword));
      if (matches.length >= 2) {
        identifiedTopics.push(topic);
      }
    });

    return identifiedTopics.length > 0 ? identifiedTopics : ['general'];
  }

  // Mock-specific methods
  getRequestCount(): number {
    return this.requestCount;
  }

  resetRequestCount(): void {
    this.requestCount = 0;
  }

  addTemplate(type: string, template: string): void {
    if (!this.templateResponses.has(type)) {
      this.templateResponses.set(type, []);
    }
    this.templateResponses.get(type)!.push(template);
  }
}
